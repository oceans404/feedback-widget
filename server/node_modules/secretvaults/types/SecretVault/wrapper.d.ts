/**
 * SecretVaultWrapper manages distributed data storage across multiple nodes.
 * It handles node authentication, data distribution, and uses NilQLWrapper
 * for field-level encryption. Provides CRUD operations with built-in
 * security and error handling.
 *
 * @example
 * const vault = new SecretVaultWrapper(nodes, credentials, schemaId);
 * await vault.init();
 * await vault.writeToNodes(data, ['sensitiveField']);
 */
export class SecretVaultWrapper {
    constructor(nodes: any, credentials: any, schemaId?: any, operation?: string, secretKey?: any, secretKeySeed?: any, tokenExpirySeconds?: number);
    nodes: any;
    nodesJwt: any[];
    credentials: any;
    schemaId: any;
    operation: string;
    tokenExpirySeconds: number;
    secretKey: any;
    secretKeySeed: any;
    nilqlWrapper: NilQLWrapper;
    /**
     * Initializes the SecretVaultWrapper by generating tokens for all nodes
     * and setting up the NilQLWrapper
     * @returns {Promise<NilQLWrapper>} Initialized NilQLWrapper instance
     */
    init(): Promise<NilQLWrapper>;
    /**
     * Updates the schema ID for the SecretVaultWrapper
     * @param {string} schemaId - The new schema ID
     */
    setSchemaId(schemaId: string, operation?: string): void;
    /**
     * Generates a JWT token for node authentication
     * @param {string} nodeDid - The DID of the node to generate token for
     * @returns {Promise<string>} JWT token
     */
    generateNodeToken(nodeDid: string): Promise<string>;
    /**
     * Generates tokens for all nodes and returns an array of objects containing node and token
     * @returns {Promise<Array<{ node: string, token: string }>>} Array of nodes with their corresponding tokens
     */
    generateTokensForAllNodes(): Promise<Array<{
        node: string;
        token: string;
    }>>;
    /**
     * Makes an HTTP request to a node's endpoint
     * @param {string} nodeUrl - URL of the node
     * @param {string} endpoint - API endpoint
     * @param {string} token - JWT token for authentication
     * @param {object} payload - Request payload
     * @returns {Promise<object>} Response data
     */
    makeRequest(nodeUrl: string, endpoint: string, token: string, payload: object, method?: string): Promise<object>;
    /**
     * Transforms data by encrypting specified fields across all nodes
     * @param {object|array} data - Data to transform
     * @returns {Promise<array>} Array of transformed data for each node
     */
    allotData(data: object | any[]): Promise<any[]>;
    /**
     * Flushes (clears) data from all nodes for the current schema
     * @returns {Promise<array>} Array of flush results from each node
     */
    flushData(): Promise<any[]>;
    /**
     * Lists schemas from all nodes in the org
     * @returns {Promise<array>} Array of schema results from each node
     */
    getSchemas(): Promise<any[]>;
    /**
     * Creates a new schema on all nodes
     * @param {object} schema - The schema to create
     * @param {string} schemaName - The name of the schema
     * @param {string} schemaId - Optional: The ID of the schema
     * @returns {Promise<array>} Array of creation results from each node
     */
    createSchema(schema: object, schemaName: string, schemaId?: string): Promise<any[]>;
    /**
     * Deletes a schema from all nodes
     * @param {string} schemaId - The ID of the schema to delete
     * @returns {Promise<array>} Array of deletion results from each node
     */
    deleteSchema(schemaId: string): Promise<any[]>;
    /**
     * Writes data to all nodes, with optional field encryption
     * @param {array} data - Data to write
     * @returns {Promise<array>} Array of write results from each node
     */
    writeToNodes(data: any[]): Promise<any[]>;
    /**
     * Reads data from all nodes with optional decryption of specified fields
     * @param {object} filter - Filter criteria for reading data
     * @returns {Promise<array>} Array of decrypted records
     */
    readFromNodes(filter?: object): Promise<any[]>;
    /**
     * Updates data on all nodes, with optional field encryption
     * @param {array} recordUpdate - Data to update
     * @param {object} filter - Filter criteria for which records to update
     * @returns {Promise<array>} Array of update results from each node
     */
    updateDataToNodes(recordUpdate: any[], filter?: object): Promise<any[]>;
    /**
     * Deletes data from all nodes based on the provided filter
     * @param {object} filter - Filter criteria for which records to delete
     * @returns {Promise<array>} Array of deletion results from each node
     */
    deleteDataFromNodes(filter?: object): Promise<any[]>;
}
import { NilQLWrapper } from "../nilQl/wrapper.js";
